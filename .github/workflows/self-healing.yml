# Self-Healing Agent
# Purpose: Automatically detect and fix workflow failures using Gemini AI
# Triggers: Executes when monitored workflows complete with failure status
# Features:
#   - Automatic issue creation with error details
#   - AI-powered error analysis using Gemini
#   - Automatic fix generation and PR creation
#   - Auto-merge after validation
#   - Issue auto-close on success
# Requirements:
#   - PAT_TOKEN secret (for PR creation)
#   - GEMINI_API_KEY secret (for AI analysis)
# Monitored workflows:
#   - Test Self-Healing Agent
#   - Gemini CLI - AI Code Assistant
#   - Webhook Event Handler
#   - Autonomous Agent Execution
#   - State Machine Automation
#   - Economic Circuit Breaker

name: ğŸ”§ Self-Healing Agent

on:
  workflow_dispatch:
  workflow_run:
    workflows:
      - "Test Self-Healing Agent"
      - "Gemini CLI - AI Code Assistant"
      - "Webhook Event Handler"
      - "Autonomous Agent Execution"
      - "State Machine Automation"
      - "Economic Circuit Breaker"
    types: [completed]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  detect-and-heal:
    name: ğŸš¨ Detect & Heal Failure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}

    steps:
      - name: Record start time
        id: start-time
        run: echo "start=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get workflow file path
        id: get-workflow
        run: bash scripts/self-healing/get-workflow-path.sh "${{ github.event.workflow_run.name }}"

      - name: Get workflow logs
        id: get-logs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: bash scripts/self-healing/get-workflow-logs.sh "${{ github.event.workflow_run.id }}" "${{ github.repository }}"

      - name: Create Issue for Failure
        id: create-issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
          RUN_ID: ${{ github.event.workflow_run.id }}
          RUN_URL: ${{ steps.get-logs.outputs.logs_url }}
          BRANCH: ${{ github.event.workflow_run.head_branch }}
          COMMIT: ${{ github.event.workflow_run.head_sha }}
          TRIGGER: ${{ github.event.workflow_run.event }}
          ACTOR: ${{ github.event.workflow_run.actor.login }}
          ERROR_SUMMARY: ${{ steps.get-logs.outputs.error_summary }}
          WORKFLOW_FILE: ${{ steps.get-workflow.outputs.workflow_file }}
          WORKFLOW_EXISTS: ${{ steps.get-workflow.outputs.workflow_exists }}
        run: |
          set -euo pipefail
          trap 'echo "::error::Failed to create issue at line $LINENO"' ERR

          echo "::notice::Creating issue for workflow failure"

          # Create issue body using environment variables
          cat > /tmp/issue_body.md << EOF
          ## ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‚¨ãƒ©ãƒ¼æ¤œå‡º

          **ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼**: \`${WORKFLOW_NAME}\`
          **Run ID**: \`${RUN_ID}\`
          **Run URL**: ${RUN_URL}
          **Branch**: \`${BRANCH}\`
          **Commit**: \`${COMMIT}\`
          **ãƒˆãƒªã‚¬ãƒ¼**: \`${TRIGGER}\`
          **å®Ÿè¡Œè€…**: @${ACTOR}

          ### ã‚¨ãƒ©ãƒ¼æ¦‚è¦

          \`\`\`json
          ${ERROR_SUMMARY}
          \`\`\`

          ### ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«

          - **Path**: \`${WORKFLOW_FILE}\`
          - **Exists**: \`${WORKFLOW_EXISTS}\`

          ---

          ğŸ¤– **Self-Healing Agent ãŒè‡ªå‹•ä¿®å¾©ã‚’é–‹å§‹ã—ã¾ã—ãŸ**

          ã“ã®Issueã¯è‡ªå‹•ã§ã‚¯ãƒ­ãƒ¼ã‚ºã•ã‚Œã¾ã™ã€‚
          EOF

          # Create issue with error handling
          if ! ISSUE_URL=$(gh issue create \
            --title "ğŸš¨ Self-Healing: ${WORKFLOW_NAME} failure" \
            --body-file /tmp/issue_body.md \
            --assignee "${ACTOR}" 2>&1); then
            echo "::error::Failed to create issue: ${ISSUE_URL}"
            exit 1
          fi

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
          echo "issue-number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "::notice::Created Issue #${ISSUE_NUMBER}: ${ISSUE_URL}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Read workflow file
        id: read-workflow
        if: steps.get-workflow.outputs.workflow_exists == 'true'
        run: bash scripts/self-healing/read-workflow.sh "${{ steps.get-workflow.outputs.workflow_file }}"

      - name: Analyze and Fix with Gemini
        uses: google-github-actions/run-gemini-cli@v0.1.13
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          prompt: |
            # Self-Healing Agent - AI-Powered Workflow Error Auto-Repair

            You are an expert DevOps engineer specializing in GitHub Actions, TypeScript, and automated error resolution.
            Your mission: analyze workflow failures and generate precise, minimal fixes that pass all tests.

            ---

            ## ğŸ“Š Context Information

            ### Project Profile
            - **Language**: TypeScript (strict mode enabled)
            - **Test Framework**: Jest with 80%+ coverage target
            - **Package Manager**: npm
            - **Node.js Version**: 20.x
            - **Code Style**: ESLint + Prettier

            ### Current Failure
            - **Workflow**: `${{ github.event.workflow_run.name }}`
            - **Issue**: #${{ steps.create-issue.outputs.issue-number }}
            - **Run URL**: ${{ steps.get-logs.outputs.logs_url }}
            - **Branch**: `${{ github.event.workflow_run.head_branch }}`
            - **Commit**: `${{ github.event.workflow_run.head_sha }}`

            ---

            ## ğŸ” Error Analysis

            ### Failed Jobs and Steps

            ```json
            ${{ steps.get-logs.outputs.error_summary }}
            ```

            ### Workflow Configuration

            **File**: `${{ steps.get-workflow.outputs.workflow_file }}`

            ```yaml
            ${{ steps.read-workflow.outputs.workflow_content }}
            ```

            ---

            ## ğŸ¯ Your Mission (3-Step Process)

            ### Step 1: Root Cause Analysis
            Analyze the error systematically:

            1. **Extract Key Error Messages**
               - Identify the exact error type (syntax, type, runtime, dependency)
               - Locate the failing line/file
               - Determine the error category

            2. **Classify Error Type**
               - `dependency`: npm package issues, version conflicts
               - `type`: TypeScript type errors, strict mode violations
               - `test`: Test failures, assertion errors
               - `config`: Configuration file issues
               - `code`: Logic bugs, runtime errors

            3. **Identify Root Cause**
               - What is the underlying issue?
               - Why did this error occur?
               - What change triggered it?

            ### Step 2: Fix Strategy Determination
            Choose the minimal, safest fix:

            1. **For Dependency Errors**
               - Update package.json versions
               - Add missing dependencies
               - Fix lock file conflicts
               - **Example**: `npm install missing-package`

            2. **For Type Errors**
               - Add proper type annotations
               - Fix type mismatches
               - Update interface definitions
               - **Example**: `const value: string = getValue()`

            3. **For Test Failures**
               - Fix test assertions
               - Update mocks/stubs
               - Correct expected values
               - **Example**: `expect(result).toBe(expectedValue)`

            4. **For Configuration Issues**
               - Update config files (tsconfig.json, jest.config.js, etc.)
               - Fix environment variables
               - **Example**: Update `compilerOptions`

            5. **For Code Bugs**
               - Fix logic errors
               - Add null checks
               - Handle edge cases
               - **Example**: `if (value !== null) { ... }`

            ### Step 3: Generate Minimal Fix
            Create the smallest possible fix that:
            - âœ… Resolves the error
            - âœ… Passes all tests
            - âœ… Maintains TypeScript strict mode compliance
            - âœ… Preserves existing functionality
            - âœ… Follows project code style

            ---

            ## ğŸš« Critical Constraints

            ### Must Follow
            - **Workflow files are READ-ONLY**: Never modify `.github/workflows/**/*.yml`
            - **Security first**: No credentials, no unsafe dependencies
            - **Minimal changes**: Fix only what's broken
            - **Type safety**: Maintain TypeScript strict mode
            - **Test coverage**: Don't reduce coverage below 80%

            ### Prohibited Actions
            - âŒ Changing workflow files
            - âŒ Disabling strict mode
            - âŒ Skipping tests with `.skip` or `.only`
            - âŒ Adding `@ts-ignore` or `@ts-nocheck`
            - âŒ Using `any` type unnecessarily
            - âŒ Installing unlisted dependencies without justification

            ---

            ## ğŸ“ Output Format (Strict JSON)

            Respond ONLY with this exact JSON structure:

            ```json
            {
              "analysis": {
                "error_type": "dependency|type|test|config|code",
                "error_message": "Exact error message from logs",
                "failed_file": "path/to/failing/file.ts",
                "failed_line": 123,
                "root_cause": "Clear explanation of why this error occurred"
              },
              "fix_strategy": {
                "approach": "Brief description of fix approach",
                "rationale": "Why this fix is correct and minimal",
                "files_to_modify": [
                  {
                    "path": "src/file.ts",
                    "reason": "Fix type error on line 45"
                  }
                ],
                "dependencies_to_add": [],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Detailed description of changes made",
                "test_commands": [
                  "npm run typecheck",
                  "npm test",
                  "npm run lint"
                ],
                "expected_outcome": "All tests pass, type check succeeds"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": false,
                "confidence_level": "high|medium|low",
                "notes": "Any additional context or warnings"
              }
            }
            ```

            ---

            ## ğŸ’¡ Few-Shot Examples

            ### Example 1: TypeScript Type Error

            **Error Log**:
            ```
            src/agents/ReviewAgent.ts:45:12 - error TS2339: Property 'score' does not exist on type 'AnalysisResult'.
            ```

            **Response**:
            ```json
            {
              "analysis": {
                "error_type": "type",
                "error_message": "Property 'score' does not exist on type 'AnalysisResult'",
                "failed_file": "src/agents/ReviewAgent.ts",
                "failed_line": 45,
                "root_cause": "The AnalysisResult interface is missing the 'score' property"
              },
              "fix_strategy": {
                "approach": "Add 'score' property to AnalysisResult interface",
                "rationale": "Minimal change, fixes type error without breaking existing code",
                "files_to_modify": [
                  {
                    "path": "src/types/AnalysisResult.ts",
                    "reason": "Add score: number to interface"
                  }
                ],
                "dependencies_to_add": [],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Added 'score: number' property to AnalysisResult interface",
                "test_commands": ["npm run typecheck", "npm test"],
                "expected_outcome": "Type error resolved, all tests pass"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": false,
                "confidence_level": "high",
                "notes": "Safe additive change"
              }
            }
            ```

            ### Example 2: Dependency Missing

            **Error Log**:
            ```
            Error: Cannot find module '@types/node'
            ```

            **Response**:
            ```json
            {
              "analysis": {
                "error_type": "dependency",
                "error_message": "Cannot find module '@types/node'",
                "failed_file": "N/A",
                "failed_line": 0,
                "root_cause": "Missing @types/node dev dependency"
              },
              "fix_strategy": {
                "approach": "Install @types/node as dev dependency",
                "rationale": "Required for Node.js type definitions",
                "files_to_modify": [],
                "dependencies_to_add": ["@types/node"],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Added @types/node to devDependencies",
                "test_commands": ["npm install", "npm run typecheck"],
                "expected_outcome": "Module found, type check passes"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": false,
                "confidence_level": "high",
                "notes": "Standard type definitions package"
              }
            }
            ```

            ### Example 3: Test Failure

            **Error Log**:
            ```
            FAIL tests/ReviewAgent.test.ts
              Expected: 80
              Received: 75
            ```

            **Response**:
            ```json
            {
              "analysis": {
                "error_type": "test",
                "error_message": "Expected: 80, Received: 75",
                "failed_file": "tests/ReviewAgent.test.ts",
                "failed_line": 25,
                "root_cause": "Test expectation does not match actual implementation result"
              },
              "fix_strategy": {
                "approach": "Update test expectation to match actual behavior",
                "rationale": "Implementation is correct, test expectation was wrong",
                "files_to_modify": [
                  {
                    "path": "tests/ReviewAgent.test.ts",
                    "reason": "Update expected value from 80 to 75"
                  }
                ],
                "dependencies_to_add": [],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Updated test expectation to match implementation",
                "test_commands": ["npm test"],
                "expected_outcome": "Test passes"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": true,
                "confidence_level": "medium",
                "notes": "Verify that 75 is the correct expected value"
              }
            }
            ```

            ---

            ## ğŸš€ Begin Auto-Repair

            Now analyze the error above and generate your fix following the exact JSON format.
            Make the minimal changes necessary to resolve the issue.
            Ensure all tests will pass after your changes.

      - name: Install dependencies
        run: |
          npm ci
        continue-on-error: true

      - name: Run type check
        run: |
          npm run typecheck
        continue-on-error: true

      - name: Run tests
        run: |
          npm test
        continue-on-error: true

      - name: Create Pull Request
        id: create-pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          commit-message: |
            fix(self-healing): Auto-fix ${{ github.event.workflow_run.name }} failure

            Fixes #${{ steps.create-issue.outputs.issue-number }}

            ğŸ¤– Self-Healing Agent ã«ã‚ˆã‚‹è‡ªå‹•ä¿®å¾©

            - ã‚¨ãƒ©ãƒ¼åŸå› ã‚’åˆ†æ
            - ä¿®å¾©ã‚³ãƒ¼ãƒ‰ã‚’è‡ªå‹•ç”Ÿæˆ
            - ãƒ†ã‚¹ãƒˆå®Ÿè¡Œæ¸ˆã¿

            Run URL: ${{ steps.get-logs.outputs.logs_url }}
          branch: self-healing/run-${{ github.event.workflow_run.id }}
          delete-branch: true
          title: "fix: Auto-heal ${{ github.event.workflow_run.name }} (#${{ steps.create-issue.outputs.issue-number }})"
          body: |
            ## ğŸ”§ Self-Healing Agent - è‡ªå‹•ä¿®å¾©å®Œäº†

            **Issue**: #${{ steps.create-issue.outputs.issue-number }}
            **Failed Workflow**: `${{ github.event.workflow_run.name }}`
            **Run ID**: `${{ github.event.workflow_run.id }}`
            **Run URL**: ${{ steps.get-logs.outputs.logs_url }}

            ---

            ### ğŸ” ã‚¨ãƒ©ãƒ¼åˆ†æ

            Gemini AI ãŒãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ãƒ­ã‚°ã¨ã‚³ãƒ¼ãƒ‰ã‚’åˆ†æã—ã¾ã—ãŸã€‚

            ### ğŸ› ï¸ ä¿®å¾©å†…å®¹

            è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸä¿®å¾©ã‚³ãƒ¼ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã¾ã™ã€‚
            è©³ç´°ã¯ Commits ã‚¿ãƒ–ã‚’å‚ç…§ã—ã¦ãã ã•ã„ã€‚

            ### âœ… æ¤œè¨¼çµæœ

            - Type check: See workflow logs
            - Tests: See workflow logs

            ---

            ğŸ¤– **ã“ã®PRã¯è‡ªå‹•ãƒãƒ¼ã‚¸ã•ã‚Œã¾ã™**

            Self-Healing Agent ã«ã‚ˆã‚‹å®Œå…¨è‡ªå¾‹ä¿®å¾©ã€‚
            å•é¡ŒãŒã‚ã‚‹å ´åˆã¯ã€ã“ã®PRã‚’ã‚¯ãƒ­ãƒ¼ã‚ºã—ã¦æ‰‹å‹•ã§ä¿®æ­£ã—ã¦ãã ã•ã„ã€‚

            ---

            Generated by Self-Healing Agent
            Co-Authored-By: Gemini AI <noreply@google.com>
          draft: false

      - name: Wait for PR checks
        if: steps.create-pr.outputs.pull-request-number != ''
        run: |
          echo "Waiting 30 seconds for PR checks to start..."
          sleep 30

      - name: Auto-merge PR
        if: steps.create-pr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          PR_NUMBER="${{ steps.create-pr.outputs.pull-request-number }}"
          echo "::notice::Attempting to auto-merge PR #${PR_NUMBER}"

          # Enable auto-merge with squash and error handling
          if gh pr merge "${PR_NUMBER}" \
            --auto \
            --squash \
            --delete-branch \
            --body "ğŸ¤– Auto-merged by Self-Healing Agent" 2>&1; then
            echo "::notice::Auto-merge enabled for PR #${PR_NUMBER}"
          else
            echo "::warning::Auto-merge failed for PR #${PR_NUMBER}. Manual review required."
            gh pr comment "${PR_NUMBER}" --body "âš ï¸ è‡ªå‹•ãƒãƒ¼ã‚¸ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ãŒå¿…è¦ã§ã™ã€‚" || echo "::error::Failed to add comment to PR"
            exit 0
          fi

      - name: Close Issue
        if: steps.create-pr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          trap 'echo "::error::Failed to close issue at line $LINENO"' ERR

          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue-number }}"
          PR_NUMBER="${{ steps.create-pr.outputs.pull-request-number }}"

          echo "::notice::Closing issue #${ISSUE_NUMBER}"

          # Add comment with error handling
          if ! gh issue comment "${ISSUE_NUMBER}" --body "âœ… è‡ªå‹•ä¿®å¾©å®Œäº†ã€‚PR #${PR_NUMBER} ã§ä¿®æ­£ã•ã‚Œã¾ã—ãŸã€‚" 2>&1; then
            echo "::warning::Failed to add comment to issue #${ISSUE_NUMBER}"
          fi

          # Close issue with error handling
          if gh issue close "${ISSUE_NUMBER}" --reason "completed" 2>&1; then
            echo "::notice::Successfully closed issue #${ISSUE_NUMBER}"
          else
            echo "::error::Failed to close issue #${ISSUE_NUMBER}"
            exit 1
          fi

      - name: Record success metrics
        if: steps.create-pr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          END_TIME=$(date +%s)
          bash scripts/self-healing/record-metrics.sh \
            "${{ steps.create-issue.outputs.issue-number }}" \
            "success" \
            "${{ steps.start-time.outputs.start }}" \
            "${END_TIME}" \
            "${{ github.event.workflow_run.name }}"

      - name: Notify on failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue-number }}"

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "::error::Cannot notify - Issue number not available"
            exit 0
          fi

          echo "::warning::Self-healing process failed. Notifying issue #${ISSUE_NUMBER}"

          # Add failure comment with error handling
          FAILURE_MESSAGE="âŒ è‡ªå‹•ä¿®å¾©ã«å¤±æ•—ã—ã¾ã—ãŸã€‚

**å¤±æ•—ã—ãŸã‚¹ãƒ†ãƒƒãƒ—**: ç¢ºèªã—ã¦ãã ã•ã„
**ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼**: ${{ github.workflow }}
**Run ID**: ${{ github.run_id }}
**Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

æ‰‹å‹•ã§ã®å¯¾å¿œãŒå¿…è¦ã§ã™ã€‚"

          if gh issue comment "${ISSUE_NUMBER}" --body "$FAILURE_MESSAGE" 2>&1; then
            echo "::notice::Failure notification added to issue #${ISSUE_NUMBER}"
          else
            echo "::error::Failed to add failure notification to issue"
          fi

      - name: Record failure metrics
        if: failure() && steps.create-issue.outputs.issue-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          END_TIME=$(date +%s)
          bash scripts/self-healing/record-metrics.sh \
            "${{ steps.create-issue.outputs.issue-number }}" \
            "failure" \
            "${{ steps.start-time.outputs.start }}" \
            "${END_TIME}" \
            "${{ github.event.workflow_run.name }}" || true
