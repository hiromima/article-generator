# Self-Healing Agent
# Purpose: Automatically detect and fix workflow failures using Gemini AI
# Triggers: Executes when monitored workflows complete with failure status
# Features:
#   - Automatic issue creation with error details
#   - AI-powered error analysis using Gemini
#   - Automatic fix generation and PR creation
#   - Auto-merge after validation
#   - Issue auto-close on success
# Requirements:
#   - PAT_TOKEN secret (for PR creation)
#   - GEMINI_API_KEY secret (for AI analysis)
# Monitored workflows:
#   - Test Self-Healing Agent
#   - Gemini CLI - AI Code Assistant
#   - Webhook Event Handler
#   - Autonomous Agent Execution
#   - State Machine Automation
#   - Economic Circuit Breaker

name: üîß Self-Healing Agent

on:
  workflow_dispatch:
  workflow_run:
    workflows:
      - "Test Self-Healing Agent"
      - "Gemini CLI - AI Code Assistant"
      - "Webhook Event Handler"
      - "Autonomous Agent Execution"
      - "State Machine Automation"
      - "Economic Circuit Breaker"
    types: [completed]

permissions:
  contents: write
  issues: write
  pull-requests: write
  actions: write

jobs:
  detect-and-heal:
    name: üö® Detect & Heal Failure
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'failure' }}

    steps:
      - name: Record start time
        id: start-time
        run: echo "start=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get workflow file path
        id: get-workflow
        run: bash scripts/self-healing/get-workflow-path.sh "${{ github.event.workflow_run.name }}"

      - name: Get workflow logs
        id: get-logs
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: bash scripts/self-healing/get-workflow-logs.sh "${{ github.event.workflow_run.id }}" "${{ github.repository }}"

      - name: Create Issue for Failure
        id: create-issue
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          WORKFLOW_NAME: ${{ github.event.workflow_run.name }}
          RUN_ID: ${{ github.event.workflow_run.id }}
          RUN_URL: ${{ steps.get-logs.outputs.logs_url }}
          BRANCH: ${{ github.event.workflow_run.head_branch }}
          COMMIT: ${{ github.event.workflow_run.head_sha }}
          TRIGGER: ${{ github.event.workflow_run.event }}
          ACTOR: ${{ github.event.workflow_run.actor.login }}
          ERROR_SUMMARY: ${{ steps.get-logs.outputs.error_summary }}
          WORKFLOW_FILE: ${{ steps.get-workflow.outputs.workflow_file }}
          WORKFLOW_EXISTS: ${{ steps.get-workflow.outputs.workflow_exists }}
        run: |
          set -euo pipefail
          trap 'echo "::error::Failed to create issue at line $LINENO"' ERR

          echo "::notice::Creating issue for workflow failure"

          # Create issue body using environment variables
          cat > /tmp/issue_body.md << EOF
          ## „ÉØ„Éº„ÇØ„Éï„É≠„Éº„Ç®„É©„ÉºÊ§úÂá∫

          **„ÉØ„Éº„ÇØ„Éï„É≠„Éº**: \`${WORKFLOW_NAME}\`
          **Run ID**: \`${RUN_ID}\`
          **Run URL**: ${RUN_URL}
          **Branch**: \`${BRANCH}\`
          **Commit**: \`${COMMIT}\`
          **„Éà„É™„Ç¨„Éº**: \`${TRIGGER}\`
          **ÂÆüË°åËÄÖ**: @${ACTOR}

          ### „Ç®„É©„ÉºÊ¶ÇË¶Å

          \`\`\`json
          ${ERROR_SUMMARY}
          \`\`\`

          ### „ÉØ„Éº„ÇØ„Éï„É≠„Éº„Éï„Ç°„Ç§„É´

          - **Path**: \`${WORKFLOW_FILE}\`
          - **Exists**: \`${WORKFLOW_EXISTS}\`

          ---

          ü§ñ **Self-Healing Agent „ÅåËá™Âãï‰øÆÂæ©„ÇíÈñãÂßã„Åó„Åæ„Åó„Åü**

          „Åì„ÅÆIssue„ÅØËá™Âãï„Åß„ÇØ„É≠„Éº„Ç∫„Åï„Çå„Åæ„Åô„ÄÇ
          EOF

          # Create issue with error handling
          if ! ISSUE_URL=$(gh issue create \
            --title "üö® Self-Healing: ${WORKFLOW_NAME} failure" \
            --body-file /tmp/issue_body.md \
            --assignee "${ACTOR}" 2>&1); then
            echo "::error::Failed to create issue: ${ISSUE_URL}"
            exit 1
          fi

          ISSUE_NUMBER=$(echo "$ISSUE_URL" | grep -oE '[0-9]+$')
          echo "issue-number=${ISSUE_NUMBER}" >> "$GITHUB_OUTPUT"
          echo "::notice::Created Issue #${ISSUE_NUMBER}: ${ISSUE_URL}"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Read workflow file
        id: read-workflow
        if: steps.get-workflow.outputs.workflow_exists == 'true'
        run: bash scripts/self-healing/read-workflow.sh "${{ steps.get-workflow.outputs.workflow_file }}"

      - name: Analyze and Fix with Gemini
        uses: google-github-actions/run-gemini-cli@v0.1.13
        with:
          gemini_api_key: ${{ secrets.GEMINI_API_KEY }}
          prompt: |
            # Self-Healing Agent - AI-Powered Workflow Error Auto-Repair

            You are an expert DevOps engineer specializing in GitHub Actions, TypeScript, and automated error resolution.
            Your mission: analyze workflow failures and generate precise, minimal fixes that pass all tests.

            ---

            ## üìä Context Information

            ### Project Profile
            - **Language**: TypeScript (strict mode enabled)
            - **Test Framework**: Jest with 80%+ coverage target
            - **Package Manager**: npm
            - **Node.js Version**: 20.x
            - **Code Style**: ESLint + Prettier

            ### Current Failure
            - **Workflow**: `${{ github.event.workflow_run.name }}`
            - **Issue**: #${{ steps.create-issue.outputs.issue-number }}
            - **Run URL**: ${{ steps.get-logs.outputs.logs_url }}
            - **Branch**: `${{ github.event.workflow_run.head_branch }}`
            - **Commit**: `${{ github.event.workflow_run.head_sha }}`

            ---

            ## üîç Error Analysis

            ### Failed Jobs and Steps

            ```json
            ${{ steps.get-logs.outputs.error_summary }}
            ```

            ### Workflow Configuration

            **File**: `${{ steps.get-workflow.outputs.workflow_file }}`

            ```yaml
            ${{ steps.read-workflow.outputs.workflow_content }}
            ```

            ---

            ## üéØ Your Mission (3-Step Process)

            ### Step 1: Root Cause Analysis
            Analyze the error systematically:

            1. **Extract Key Error Messages**
               - Identify the exact error type (syntax, type, runtime, dependency)
               - Locate the failing line/file
               - Determine the error category

            2. **Classify Error Type**
               - `dependency`: npm package issues, version conflicts
               - `type`: TypeScript type errors, strict mode violations
               - `test`: Test failures, assertion errors
               - `config`: Configuration file issues
               - `code`: Logic bugs, runtime errors

            3. **Identify Root Cause**
               - What is the underlying issue?
               - Why did this error occur?
               - What change triggered it?

            ### Step 2: Fix Strategy Determination
            Choose the minimal, safest fix:

            1. **For Dependency Errors**
               - Update package.json versions
               - Add missing dependencies
               - Fix lock file conflicts
               - **Example**: `npm install missing-package`

            2. **For Type Errors**
               - Add proper type annotations
               - Fix type mismatches
               - Update interface definitions
               - **Example**: `const value: string = getValue()`

            3. **For Test Failures**
               - Fix test assertions
               - Update mocks/stubs
               - Correct expected values
               - **Example**: `expect(result).toBe(expectedValue)`

            4. **For Configuration Issues**
               - Update config files (tsconfig.json, jest.config.js, etc.)
               - Fix environment variables
               - **Example**: Update `compilerOptions`

            5. **For Code Bugs**
               - Fix logic errors
               - Add null checks
               - Handle edge cases
               - **Example**: `if (value !== null) { ... }`

            ### Step 3: Generate Minimal Fix
            Create the smallest possible fix that:
            - ‚úÖ Resolves the error
            - ‚úÖ Passes all tests
            - ‚úÖ Maintains TypeScript strict mode compliance
            - ‚úÖ Preserves existing functionality
            - ‚úÖ Follows project code style

            ---

            ## üö´ Critical Constraints

            ### Must Follow
            - **Workflow files are READ-ONLY**: Never modify `.github/workflows/**/*.yml`
            - **Security first**: No credentials, no unsafe dependencies
            - **Minimal changes**: Fix only what's broken
            - **Type safety**: Maintain TypeScript strict mode
            - **Test coverage**: Don't reduce coverage below 80%

            ### Prohibited Actions
            - ‚ùå Changing workflow files
            - ‚ùå Disabling strict mode
            - ‚ùå Skipping tests with `.skip` or `.only`
            - ‚ùå Adding `@ts-ignore` or `@ts-nocheck`
            - ‚ùå Using `any` type unnecessarily
            - ‚ùå Installing unlisted dependencies without justification

            ---

            ## üìù Output Format (Strict JSON)

            Respond ONLY with this exact JSON structure:

            ```json
            {
              "analysis": {
                "error_type": "dependency|type|test|config|code",
                "error_message": "Exact error message from logs",
                "failed_file": "path/to/failing/file.ts",
                "failed_line": 123,
                "root_cause": "Clear explanation of why this error occurred"
              },
              "fix_strategy": {
                "approach": "Brief description of fix approach",
                "rationale": "Why this fix is correct and minimal",
                "files_to_modify": [
                  {
                    "path": "src/file.ts",
                    "reason": "Fix type error on line 45"
                  }
                ],
                "dependencies_to_add": [],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Detailed description of changes made",
                "test_commands": [
                  "npm run typecheck",
                  "npm test",
                  "npm run lint"
                ],
                "expected_outcome": "All tests pass, type check succeeds"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": false,
                "confidence_level": "high|medium|low",
                "notes": "Any additional context or warnings"
              }
            }
            ```

            ---

            ## üí° Few-Shot Examples

            ### Example 1: TypeScript Type Error

            **Error Log**:
            ```
            src/agents/ReviewAgent.ts:45:12 - error TS2339: Property 'score' does not exist on type 'AnalysisResult'.
            ```

            **Response**:
            ```json
            {
              "analysis": {
                "error_type": "type",
                "error_message": "Property 'score' does not exist on type 'AnalysisResult'",
                "failed_file": "src/agents/ReviewAgent.ts",
                "failed_line": 45,
                "root_cause": "The AnalysisResult interface is missing the 'score' property"
              },
              "fix_strategy": {
                "approach": "Add 'score' property to AnalysisResult interface",
                "rationale": "Minimal change, fixes type error without breaking existing code",
                "files_to_modify": [
                  {
                    "path": "src/types/AnalysisResult.ts",
                    "reason": "Add score: number to interface"
                  }
                ],
                "dependencies_to_add": [],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Added 'score: number' property to AnalysisResult interface",
                "test_commands": ["npm run typecheck", "npm test"],
                "expected_outcome": "Type error resolved, all tests pass"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": false,
                "confidence_level": "high",
                "notes": "Safe additive change"
              }
            }
            ```

            ### Example 2: Dependency Missing

            **Error Log**:
            ```
            Error: Cannot find module '@types/node'
            ```

            **Response**:
            ```json
            {
              "analysis": {
                "error_type": "dependency",
                "error_message": "Cannot find module '@types/node'",
                "failed_file": "N/A",
                "failed_line": 0,
                "root_cause": "Missing @types/node dev dependency"
              },
              "fix_strategy": {
                "approach": "Install @types/node as dev dependency",
                "rationale": "Required for Node.js type definitions",
                "files_to_modify": [],
                "dependencies_to_add": ["@types/node"],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Added @types/node to devDependencies",
                "test_commands": ["npm install", "npm run typecheck"],
                "expected_outcome": "Module found, type check passes"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": false,
                "confidence_level": "high",
                "notes": "Standard type definitions package"
              }
            }
            ```

            ### Example 3: Test Failure

            **Error Log**:
            ```
            FAIL tests/ReviewAgent.test.ts
              Expected: 80
              Received: 75
            ```

            **Response**:
            ```json
            {
              "analysis": {
                "error_type": "test",
                "error_message": "Expected: 80, Received: 75",
                "failed_file": "tests/ReviewAgent.test.ts",
                "failed_line": 25,
                "root_cause": "Test expectation does not match actual implementation result"
              },
              "fix_strategy": {
                "approach": "Update test expectation to match actual behavior",
                "rationale": "Implementation is correct, test expectation was wrong",
                "files_to_modify": [
                  {
                    "path": "tests/ReviewAgent.test.ts",
                    "reason": "Update expected value from 80 to 75"
                  }
                ],
                "dependencies_to_add": [],
                "dependencies_to_update": []
              },
              "implementation": {
                "description": "Updated test expectation to match implementation",
                "test_commands": ["npm test"],
                "expected_outcome": "Test passes"
              },
              "validation": {
                "breaking_changes": false,
                "requires_manual_review": true,
                "confidence_level": "medium",
                "notes": "Verify that 75 is the correct expected value"
              }
            }
            ```

            ---

            ## üöÄ Begin Auto-Repair

            Now analyze the error above and generate your fix following the exact JSON format.
            Make the minimal changes necessary to resolve the issue.
            Ensure all tests will pass after your changes.

      - name: Install dependencies
        run: |
          npm ci
        continue-on-error: true

      - name: Run type check
        run: |
          npm run typecheck
        continue-on-error: true

      - name: Run tests
        run: |
          npm test
        continue-on-error: true

      - name: Create Pull Request
        id: create-pr
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.PAT_TOKEN || secrets.GITHUB_TOKEN }}
          commit-message: |
            fix(self-healing): Auto-fix ${{ github.event.workflow_run.name }} failure

            Fixes #${{ steps.create-issue.outputs.issue-number }}

            ü§ñ Self-Healing Agent „Å´„Çà„ÇãËá™Âãï‰øÆÂæ©

            - „Ç®„É©„ÉºÂéüÂõ†„ÇíÂàÜÊûê
            - ‰øÆÂæ©„Ç≥„Éº„Éâ„ÇíËá™ÂãïÁîüÊàê
            - „ÉÜ„Çπ„ÉàÂÆüË°åÊ∏à„Åø

            Run URL: ${{ steps.get-logs.outputs.logs_url }}
          branch: self-healing/run-${{ github.event.workflow_run.id }}
          delete-branch: true
          title: "fix: Auto-heal ${{ github.event.workflow_run.name }} (#${{ steps.create-issue.outputs.issue-number }})"
          body: |
            ## üîß Self-Healing Agent - Ëá™Âãï‰øÆÂæ©ÂÆå‰∫Ü

            **Issue**: #${{ steps.create-issue.outputs.issue-number }}
            **Failed Workflow**: `${{ github.event.workflow_run.name }}`
            **Run ID**: `${{ github.event.workflow_run.id }}`
            **Run URL**: ${{ steps.get-logs.outputs.logs_url }}

            ---

            ### üîç „Ç®„É©„ÉºÂàÜÊûê

            Gemini AI „Åå„ÉØ„Éº„ÇØ„Éï„É≠„Éº„É≠„Ç∞„Å®„Ç≥„Éº„Éâ„ÇíÂàÜÊûê„Åó„Åæ„Åó„Åü„ÄÇ

            ### üõ†Ô∏è ‰øÆÂæ©ÂÜÖÂÆπ

            Ëá™ÂãïÁîüÊàê„Åï„Çå„Åü‰øÆÂæ©„Ç≥„Éº„Éâ„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Åæ„Åô„ÄÇ
            Ë©≥Á¥∞„ÅØ Commits „Çø„Éñ„ÇíÂèÇÁÖß„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

            ### ‚úÖ Ê§úË®ºÁµêÊûú

            - Type check: See workflow logs
            - Tests: See workflow logs

            ---

            ü§ñ **„Åì„ÅÆPR„ÅØËá™Âãï„Éû„Éº„Ç∏„Åï„Çå„Åæ„Åô**

            Self-Healing Agent „Å´„Çà„ÇãÂÆåÂÖ®Ëá™Âæã‰øÆÂæ©„ÄÇ
            ÂïèÈ°å„Åå„ÅÇ„ÇãÂ†¥Âêà„ÅØ„ÄÅ„Åì„ÅÆPR„Çí„ÇØ„É≠„Éº„Ç∫„Åó„Å¶ÊâãÂãï„Åß‰øÆÊ≠£„Åó„Å¶„Åè„Å†„Åï„ÅÑ„ÄÇ

            ---

            Generated by Self-Healing Agent
            Co-Authored-By: Gemini AI <noreply@google.com>
          draft: false

      - name: Wait for PR checks
        if: steps.create-pr.outputs.pull-request-number != ''
        run: |
          echo "Waiting 30 seconds for PR checks to start..."
          sleep 30

      - name: Auto-merge PR
        if: steps.create-pr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          PR_NUMBER="${{ steps.create-pr.outputs.pull-request-number }}"
          echo "::notice::Attempting to auto-merge PR #${PR_NUMBER}"

          # Enable auto-merge with squash and error handling
          if gh pr merge "${PR_NUMBER}" \
            --auto \
            --squash \
            --delete-branch \
            --body "ü§ñ Auto-merged by Self-Healing Agent" 2>&1; then
            echo "::notice::Auto-merge enabled for PR #${PR_NUMBER}"
          else
            echo "::warning::Auto-merge failed for PR #${PR_NUMBER}. Manual review required."
            gh pr comment "${PR_NUMBER}" --body "‚ö†Ô∏è Ëá™Âãï„Éû„Éº„Ç∏„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇÊâãÂãï„É¨„Éì„É•„Éº„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ" || echo "::error::Failed to add comment to PR"
            exit 0
          fi

      - name: Close Issue
        if: steps.create-pr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          trap 'echo "::error::Failed to close issue at line $LINENO"' ERR

          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue-number }}"
          PR_NUMBER="${{ steps.create-pr.outputs.pull-request-number }}"

          echo "::notice::Closing issue #${ISSUE_NUMBER}"

          # Add comment with error handling
          if ! gh issue comment "${ISSUE_NUMBER}" --body "‚úÖ Ëá™Âãï‰øÆÂæ©ÂÆå‰∫Ü„ÄÇPR #${PR_NUMBER} „Åß‰øÆÊ≠£„Åï„Çå„Åæ„Åó„Åü„ÄÇ" 2>&1; then
            echo "::warning::Failed to add comment to issue #${ISSUE_NUMBER}"
          fi

          # Close issue with error handling
          if gh issue close "${ISSUE_NUMBER}" --reason "completed" 2>&1; then
            echo "::notice::Successfully closed issue #${ISSUE_NUMBER}"
          else
            echo "::error::Failed to close issue #${ISSUE_NUMBER}"
            exit 1
          fi

      - name: Record success metrics
        if: steps.create-pr.outputs.pull-request-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          END_TIME=$(date +%s)
          bash scripts/self-healing/record-metrics.sh \
            "${{ steps.create-issue.outputs.issue-number }}" \
            "success" \
            "${{ steps.start-time.outputs.start }}" \
            "${END_TIME}" \
            "${{ github.event.workflow_run.name }}"

      - name: Notify on failure
        if: failure()
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail

          ISSUE_NUMBER="${{ steps.create-issue.outputs.issue-number }}"

          if [ -z "$ISSUE_NUMBER" ]; then
            echo "::error::Cannot notify - Issue number not available"
            exit 0
          fi

          echo "::warning::Self-healing process failed. Notifying issue #${ISSUE_NUMBER}"

          # Add failure comment with error handling
          FAILURE_MESSAGE="‚ùå Ëá™Âãï‰øÆÂæ©„Å´Â§±Êïó„Åó„Åæ„Åó„Åü„ÄÇ

**Â§±Êïó„Åó„Åü„Çπ„ÉÜ„ÉÉ„Éó**: Á¢∫Ë™ç„Åó„Å¶„Åè„Å†„Åï„ÅÑ
**„ÉØ„Éº„ÇØ„Éï„É≠„Éº**: ${{ github.workflow }}
**Run ID**: ${{ github.run_id }}
**Run URL**: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}

ÊâãÂãï„Åß„ÅÆÂØæÂøú„ÅåÂøÖË¶Å„Åß„Åô„ÄÇ"

          if gh issue comment "${ISSUE_NUMBER}" --body "$FAILURE_MESSAGE" 2>&1; then
            echo "::notice::Failure notification added to issue #${ISSUE_NUMBER}"
          else
            echo "::error::Failed to add failure notification to issue"
          fi

      - name: Record failure metrics
        if: failure() && steps.create-issue.outputs.issue-number != ''
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          END_TIME=$(date +%s)
          bash scripts/self-healing/record-metrics.sh \
            "${{ steps.create-issue.outputs.issue-number }}" \
            "failure" \
            "${{ steps.start-time.outputs.start }}" \
            "${END_TIME}" \
            "${{ github.event.workflow_run.name }}" || true
